---
description: Enforce non-negotiable standards for Atomic Design System in frontend projects
globs:
  - "src/**/*"
alwaysApply: false
---

# ğŸ§ª Standard Operating Procedure: Atomic Design System

**Status:** Mandatory  
**Version:** 1.0

---

## Table of Contents

1. [Purpose](mdc:#purpose)
2. [Principles](mdc:#principles)
3. [Clean Architecture Integration](mdc:#clean-architecture-integration)
4. [Directory Structure](mdc:#directory-structure)
5. [Component Levels](mdc:#component-levels)
6. [Component Placement Guidelines](mdc:#component-placement-guidelines)
7. [Component Registry System](mdc:#component-registry-system)
8. [Best Practices](mdc:#best-practices)

---

## Purpose

Atomic Design methodology for creating design systems by breaking down components into five distinct levels: atoms, molecules, organisms, templates, and pages. This architecture integrates seamlessly with our Clean Architecture principles (Layer 4: Frameworks & Drivers).

## Principles

1. **Hierarchical Composition**: Components build upon each other from simple to complex
2. **Reusability**: Lower-level components are highly reusable
3. **Consistency**: Enforces design and interaction consistency across the application
4. **Modularity**: Each component is self-contained with clear inputs and outputs
5. **Progressive Enhancement**: Start small and build up to complete interfaces

## Clean Architecture Integration

Atomic Design operates within **Layer 4: Frameworks & Drivers** of our Clean Architecture:

- **Global Components**: `src/shared/components/` - Shared UI components across all features
- **Feature Components**: `src/features/{feature}/components/` - Feature-specific atomic components
- **Routes**: `src/app/` - Next.js App Router pages that consume components and hooks

### Dependency Rule Compliance

- **These are non-negotiable rules that must be strictly followed**
- Components (Layer 4) can use hooks (Layer 3)
- Components delegate all business logic to hooks
- Components are "dumb" and focus purely on presentation

## Directory Structure

### Two-Tier Architecture: Global + Feature-Specific

```
src/
â”œâ”€â”€ shared/
â”‚   â””â”€â”€ components/                 # ğŸŒ Global Design System (Layer 4)
â”‚       â”œâ”€â”€ atoms/                  # Global atoms (Button, Input, Card...)
â”‚       â”‚   â”œâ”€â”€ Button/
â”‚       â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚       â”‚   â”‚   â””â”€â”€ index.ts
â”‚       â”‚   â””â”€â”€ index.ts            # Export all atoms
â”‚       â”œâ”€â”€ molecules/              # Global molecules (SearchBar, etc.)
â”‚       â”œâ”€â”€ organisms/              # Global organisms (Header, Footer...)
â”‚       â”œâ”€â”€ templates/              # Global layouts/templates
â”‚       â””â”€â”€ index.ts                # Master export for all shared components
â”‚
â”œâ”€â”€ features/                       # ğŸ§  Feature-based Clean Architecture
â”‚   â””â”€â”€ {feature-name}/
â”‚       â”œâ”€â”€ components/             # Feature-specific Atomic Components (Layer 4)
â”‚       â”‚   â”œâ”€â”€ atoms/              # e.g., ItemLabel, ItemIcon
â”‚       â”‚   â”œâ”€â”€ molecules/          # e.g., ItemForm, ItemCard
â”‚       â”‚   â”œâ”€â”€ organisms/          # e.g., ItemList, ItemDashboard
â”‚       â”‚   â””â”€â”€ templates/          # e.g., ItemPageLayout
â”‚       â”œâ”€â”€ routes/                 # Layer 4: Next.js pages using components+hooks
â”‚       â”œâ”€â”€ hooks/                  # Layer 3: Custom hooks (DI container)
â”‚       â”œâ”€â”€ application/            # Layer 2: Use cases
â”‚       â”œâ”€â”€ services/               # Layer 3: Service adapters
â”‚       â”œâ”€â”€ repositories/           # Layer 3: Data access
â”‚       â”œâ”€â”€ interfaces/             # Layer 2: Contracts
â”‚       â””â”€â”€ types/                  # Layer 1: Business entities
â”‚
â””â”€â”€ app/                           # Next.js App Router (Layer 4 entry points)
    â”œâ”€â”€ (feature-group)/
    â”‚   â”œâ”€â”€ page.tsx               # Uses feature components + hooks
    â”‚   â””â”€â”€ layout.tsx             # Uses global + feature templates
    â””â”€â”€ layout.tsx                 # Root layout with global components
```

## Component Placement Guidelines

### ğŸŒ Global Components (`src/shared/components/`)

Use for truly shared UI components reusable across **multiple features**:

- âœ… **Atoms**: `Button`, `Input`, `Card`, `Icon`, `Badge`
- âœ… **Molecules**: `SearchBar`, `Pagination`, `Breadcrumb`
- âœ… **Organisms**: `Header`, `Footer`, `Navigation`, `Sidebar`
- âœ… **Templates**: `PageLayout`, `DashboardLayout`, `AuthLayout`

### ğŸ§  Feature Components (`src/features/{feature}/components/`)

Use for components specific to **one feature only**:

- âœ… **Atoms**: `ItemIcon`, `ItemStatus`, `ItemLabel`
- âœ… **Molecules**: `ItemForm`, `ItemCard`, `ItemSummary`
- âœ… **Organisms**: `ItemList`, `ItemDashboard`, `ItemFilters`
- âœ… **Templates**: `ItemPageLayout`, `ItemDetailsLayout`

### ğŸ“ Promotion Rule

**Move components from feature â†’ global only when needed by multiple features**

1. Start in `src/features/{feature}/components/`
2. If another feature needs it â†’ promote to `src/components/`
3. Keep global library clean and focused

## Component Registry System

### Global Component Exports (`src/shared/components/index.ts`)

```typescript
// src/shared/components/index.ts - Clean exports for global components
export * from "./atoms";
export * from "./molecules";
export * from "./organisms";
export * from "./templates";

// src/shared/components/atoms/index.ts
export { Button } from "./Button";
export { Input } from "./Input";
export { Card } from "./Card";

// Usage in features or app routes
import { Button, Card } from "@/shared/components";
```

### Feature Component Exports (`src/features/{feature}/components/index.ts`)

```typescript
// src/features/items/components/index.ts
export * from "./atoms";
export * from "./molecules";
export * from "./organisms";
export * from "./templates";

// Usage in same feature
import { ItemForm, ItemCard } from "./components";

// Usage from app routes
import { ItemForm } from "@/features/items/components";
```

## Example Structure

### Items Feature with Clean Architecture + Atomic Design

```
src/features/items/
â”œâ”€â”€ components/                    # Layer 4: Atomic Design Components
â”‚   â”œâ”€â”€ atoms/
â”‚   â”‚   â”œâ”€â”€ ItemIcon/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemIcon.tsx
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ ItemStatus/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemStatus.tsx
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ index.ts               # Export all atoms
â”‚   â”œâ”€â”€ molecules/
â”‚   â”‚   â”œâ”€â”€ ItemCard/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemCard.tsx       # Uses ItemIcon, ItemStatus atoms
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ ItemForm/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemForm.tsx       # Uses global Button, Input atoms
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ organisms/
â”‚   â”‚   â”œâ”€â”€ ItemList/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemList.tsx       # Uses ItemCard molecules
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ ItemPageLayout/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemPageLayout.tsx # Uses global + feature organisms
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ index.ts                   # Export all atomic components
â”œâ”€â”€ hooks/                         # Layer 3: Custom hooks
â”œâ”€â”€ application/                   # Layer 2: Use cases
â”œâ”€â”€ repositories/                  # Layer 3: Data access
â””â”€â”€ types/                         # Layer 1: Business entities
```

### App Router Integration

```
src/app/
â”œâ”€â”€ items/
â”‚   â”œâ”€â”€ page.tsx                   # Uses ItemList organism + useItems hook
â”‚   â”œâ”€â”€ create/
â”‚   â”‚   â””â”€â”€ page.tsx              # Uses ItemForm molecule + useCreateItem hook
â”‚   â””â”€â”€ [id]/
â”‚       â””â”€â”€ page.tsx              # Uses ItemDetails + useItemDetails hook
â””â”€â”€ layout.tsx                    # Uses global Header, Footer organisms
```

## Component Levels

### 1. Atoms

The basic building blocks of the interface, such as buttons, inputs, labels, and icons. They are:

- The smallest functional UI elements
- Rarely useful on their own
- Highly reusable across the application
- Should be designed for versatility

```tsx
// src/shared/components/atoms/Button/Button.tsx - Global shared button
export function Button({
  onClick,
  disabled,
  children,
  variant = "primary",
  className = "",
}: ButtonProps) {
  const baseClasses = "px-4 py-2 rounded-md font-medium transition-colors";
  const variantClasses = {
    primary: "bg-blue-600 text-white hover:bg-blue-700",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300",
  };

  return (
    <button
      className={`${baseClasses} ${variantClasses[variant]} ${className}`}
      onClick={onClick}
      disabled={disabled}
      type="button"
    >
      {children}
    </button>
  );
}

// src/features/items/components/atoms/ItemStatus/ItemStatus.tsx - Feature-specific atom
export function ItemStatus({ status, className = "" }: ItemStatusProps) {
  const statusColors = {
    active: "bg-green-100 text-green-800",
    inactive: "bg-gray-100 text-gray-800",
    pending: "bg-yellow-100 text-yellow-800",
  };

  return (
    <span
      className={`px-2 py-1 rounded-full text-xs font-medium ${statusColors[status]} ${className}`}
    >
      {status}
    </span>
  );
}
```

### 2. Molecules

Simple groups of UI elements functioning together as a unit. Molecules are:

- Combinations of atoms bound together
- Relatively simple functional units
- Focused on doing one thing well
- Reusable in different contexts

```tsx
// src/features/items/components/molecules/ItemCard/ItemCard.tsx
import { ItemStatus } from "../atoms/ItemStatus";
import { ItemIcon } from "../atoms/ItemIcon";
import { Button } from "@/shared/components"; // Global button

export function ItemCard({ item, onEdit, onDelete }: ItemCardProps) {
  return (
    <div className="bg-white rounded-lg shadow-md p-6 border border-gray-200">
      <div className="flex items-start justify-between mb-4">
        <div className="flex items-center space-x-3">
          <ItemIcon type={item.category} size="lg" />
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              {item.title}
            </h3>
            <p className="text-sm text-gray-600">{item.description}</p>
          </div>
        </div>
        <ItemStatus status={item.status} />
      </div>

      <div className="flex space-x-2">
        <Button variant="secondary" onClick={() => onEdit(item.id)}>
          Edit
        </Button>
        <Button variant="danger" onClick={() => onDelete(item.id)}>
          Delete
        </Button>
      </div>
    </div>
  );
}
```

### 3. Organisms

Complex UI components composed of molecules and atoms. Organisms:

- Form distinct sections of an interface
- Represent complex pieces of functionality
- May contain component-specific business logic
- Are more context-specific than molecules

```tsx
// src/features/items/components/organisms/ItemList/ItemList.tsx
import { ItemCard } from "../molecules/ItemCard";
import { LoadingSpinner, ErrorMessage } from "@/shared/components"; // Global components
import { useItems } from "../../hooks/useItems"; // Layer 3 hook

export function ItemList({ onEditItem, onDeleteItem }: ItemListProps) {
  // Use hook (Layer 3) to get data and actions - Clean Architecture compliance
  const { items, isLoading, error, deleteItem } = useItems();

  if (isLoading) {
    return <LoadingSpinner message="Loading items..." />;
  }

  if (error) {
    return <ErrorMessage error={error} />;
  }

  return (
    <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
      {items.map((item) => (
        <ItemCard
          key={item.id}
          item={item}
          onEdit={onEditItem}
          onDelete={(id) => {
            deleteItem(id); // Delegate to hook (Layer 3)
            onDeleteItem?.(id);
          }}
        />
      ))}
    </div>
  );
}
```

### 4. Templates

Page-level structures that arrange organisms, molecules, and atoms into a layout. Templates:

- Define the layout structure of a page
- Focus on content structure, not the content itself
- Can be reused across similar pages
- Often contain placeholders for dynamic content

```tsx
// src/features/items/components/templates/ItemPageLayout/ItemPageLayout.tsx
import { PageLayout } from "@/shared/components"; // Global template
import { ItemList } from "../organisms/ItemList";
import { useRouter } from "next/navigation";

export function ItemPageLayout({
  title,
  actions,
  children,
}: ItemPageLayoutProps) {
  const router = useRouter();

  const handleEditItem = (itemId: string) => {
    router.push(`/items/${itemId}/edit`);
  };

  const handleDeleteItem = (itemId: string) => {
    // Could trigger a confirmation modal, etc.
    console.log("Item deleted:", itemId);
  };

  return (
    <PageLayout title={title} actions={actions}>
      <div className="space-y-6">
        {children}
        <ItemList onEditItem={handleEditItem} onDeleteItem={handleDeleteItem} />
      </div>
    </PageLayout>
  );
}
```

### 5. Pages

Specific instances of templates that present real content to users. Pages:

- Represent specific use cases of the application
- Connect to application data and state
- Handle page-level interactions and flows
- Are the final result of the atomic design process

```tsx
// src/app/items/page.tsx - Next.js App Router page (Layer 4 entry point)
import { ItemPageLayout } from "@/features/items/components/templates/ItemPageLayout";
import { Button } from "@/shared/components";
import Link from "next/link";

export default function ItemsPage() {
  const actions = (
    <Link href="/items/create">
      <Button variant="primary">Create New Item</Button>
    </Link>
  );

  return (
    <ItemPageLayout title="Items Dashboard" actions={actions}>
      {/* Additional page-specific content can go here */}
      <p className="text-gray-600">
        Manage your items below. You can view, edit, or delete existing items.
      </p>
    </ItemPageLayout>
  );
}

// src/app/items/create/page.tsx - Create item page
import { ItemForm } from "@/features/items/components/molecules/ItemForm";
import { PageLayout } from "@/shared/components";

export default function CreateItemPage() {
  return (
    <PageLayout title="Create New Item">
      <div className="max-w-2xl mx-auto">
        <ItemForm mode="create" />
      </div>
    </PageLayout>
  );
}
```

## Export Patterns

### Clean Barrel Exports for Atomic Hierarchy

```typescript
// src/shared/components/index.ts - Global design system exports
export * from "./atoms";
export * from "./molecules";
export * from "./organisms";
export * from "./templates";

// src/shared/components/atoms/index.ts
export { Button } from "./Button";
export { Input } from "./Input";
export { Card } from "./Card";
export { LoadingSpinner } from "./LoadingSpinner";
export { ErrorMessage } from "./ErrorMessage";

// src/features/items/components/index.ts - Feature component exports
export * from "./atoms";
export * from "./molecules";
export * from "./organisms";
export * from "./templates";

// src/features/items/components/atoms/index.ts
export { ItemIcon } from "./ItemIcon";
export { ItemStatus } from "./ItemStatus";
export { ItemLabel } from "./ItemLabel";
```

## Component Pattern

Each component should follow a consistent pattern:

1. **Single Responsibility**: Each component should do one thing well
2. **Props Interface**: Clearly define prop interfaces at the top
3. **Functional Components**: Use functional components with hooks
4. **Default Exports**: Avoid default exports to ensure consistent naming
5. **Component Directory**: Each component should have its own directory
6. **Barrel Files**: Use index.ts barrel files for clean exports

## Component Discovery & Usage

### Import Examples Following Clean Architecture

```typescript
// âœ… App Router pages (Layer 4) - use both global + feature components
import { Button, PageLayout } from "@/shared/components"; // Global design system
import { ItemList, ItemForm } from "@/features/items/components"; // Feature components

// âœ… Feature templates - use global + feature components
import { PageLayout } from "@/shared/components"; // Global template
import { ItemList } from "../organisms/ItemList"; // Feature organism

// âœ… Feature organisms - mix atoms/molecules as needed
import { ItemCard } from "../molecules/ItemCard"; // Feature molecule
import { LoadingSpinner } from "@/shared/components"; // Global atom

// âœ… Feature molecules - combine atoms
import { ItemStatus, ItemIcon } from "../atoms"; // Feature atoms
import { Button } from "@/shared/components"; // Global atom
```

## Best Practices

### ğŸ—ï¸ Clean Architecture Compliance

1. **Layer 4 Only**: Components belong only in Layer 4 (Frameworks & Drivers)
2. **Hook Delegation**: Components delegate ALL business logic to hooks (Layer 3)
3. **Pure Presentation**: Components are "dumb" and focus only on UI rendering
4. **Dependency Direction**: Components can import hooks, never the reverse

### ğŸ§ª Atomic Design Principles

5. **Component Focus**: Keep components small and focused on single responsibility
6. **Hierarchical Composition**: Build complex components from simpler ones
7. **Promotion Strategy**: Start feature-specific, promote to global only when needed
8. **Consistent Patterns**: Use consistent naming and folder structure

### ğŸ¨ Code Quality Standards

9. **TypeScript First**: Use interfaces for all component props
10. **Accessibility Built-in**: Ensure WCAG compliance in atoms/molecules
11. **Responsive Design**: Design mobile-first, work across all screen sizes
12. **Performance**: Optimize re-renders, use React.memo when beneficial

### ğŸ“ Organization Rules

13. **Clear Imports**: Use barrel exports for clean import statements
14. **Component Directories**: Each component gets its own folder with index.ts
15. **Thoughtful Placement**: Consider scope carefully (global vs feature-specific)
16. **Avoid Default Exports**: Use named exports for consistent component naming

### ğŸ”„ Development Workflow

17. **TDD Compatible**: Design components to be easily testable
18. **Storybook Ready**: Components should work in isolation
19. **Props Documentation**: Document expected props and behavior
20. **Error Boundaries**: Handle errors gracefully with fallback UI
