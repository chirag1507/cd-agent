---
description: Enforce non-negotiable standards for consumer driven contract tests in frontend projects
globs:
  - "src/**/*"
alwaysApply: false
---

# ðŸ§ª Standard Operating Procedure: Consumer Driven Contract Tests

**Status:** Mandatory  
**Version:** 1.0

---

## Table of Contents

1. [Purpose](#1-purpose)
2. [Scope](#2-scope)
   - [Guiding Principles](#guiding-principles)
   - [The Automated Contract Testing Workflow](#the-automated-contract-testing-workflow)
   - [Non-Negotiable Rules for Consumer Contract Tests](#non-negotiable-rules-for-consumer-contract-tests)
3. [Complete Implementation Examples](#complete-implementation-examples)
   - [Basic Pact Setup](#basic-pact-setup)
   - [Entity Repository Contract Test](#entity-repository-contract-test)
   - [Package.json Scripts](#packagejson-scripts)
   - [Jest Configuration for Pact](#jest-configuration-for-pact)

---

## 1. Purpose

Adherence to this SOP is mandatory for all Frontend Consumer Driven Contract Tests. Deviations are not permitted without explicit architectural review and approval. As the consumer, we are responsible for clearly and accurately defining the expectations we have of our providers.

This SOP defines the standards for writing Frontend Contract Tests within frontend applications.

## 2. Scope

This SOP applies to all contract tests written for the frontend application.

### Guiding Principles

- **Define, Don't Assume**: We must explicitly define every part of the API responses we rely on. The contract is our specification. If a field is not in the contract, there is no guarantee it will exist.
- **Fast, Local Feedback**: Contract tests run as part of our local test suite, providing immediate feedback that our API client code works with the expectations we have defined.
- **Drive the Integration**: We drive the integration. By publishing a new contract, we are signaling a new requirement to the provider. The automated CI/CD process ensures the provider is immediately notified of this change.

### The Automated Contract Testing Workflow

1.  **Write a Contract Test**: For any code that communicates with a provider (e.g., `EntityRepositoryImpl`), a corresponding contract test **must** be created in the `__tests__` directory.
2.  **Define Expectations**: Using the Pact DSL, we define the interaction. This includes:
    - `state`: The provider state required for the test (e.g., "an item with this ID does not exist").
    - `uponReceiving`: A clear description of the test case.
    - `withRequest`: The exact HTTP request our client will make.
    - `willRespondWith`: The HTTP response we expect, using `Matchers` (e.g., `like`, `eachLike`) to define the structure and type of the body, not just exact values.
3.  **Generate the Contract**: Running the tests locally (`npm run test:contract`) generates a `pact.json` file in the `/pacts` directory. This is the contract.
4.  **Automated Publication**: When a change is pushed to the `main` branch, the `commit-stage.yml` workflow automatically runs the `publish:pacts` script. This script uploads the new contract to the central Pact Broker, versioned with the commit SHA and tagged with `main`. This publication is what triggers the provider's verification process.

### Non-Negotiable Rules for Consumer Contract Tests

1.  **A Contract is Mandatory**: Every API client that communicates with a provider **must** be covered by a contract test. There are no exceptions.
2.  **Contracts Live with the Code**: Contract tests are unit tests for your API client code. They live alongside the code they test and are maintained by the same team.
3.  **Be Specific in What You Need, Flexible in What You Get**: Use matchers (`like`, `eachLike`) for response values. This ensures the provider must return the correct _type_ and _shape_ of data, but allows the actual values to change without breaking the contract. Do not assert on values you can't control (e.g., generated IDs, dates).
4.  **Do Not Commit Pact Files**: The `/pacts` directory is a build artifact directory. It **must** be included in the `.gitignore` file and **must not** be committed to the repository.
5.  **Test Before You Push**: Developers **must** run `npm run test:contract` locally to ensure their changes correctly generate a pact file before pushing their code.
6.  **Communicate Breaking Changes**: While the pipeline provides the technical feedback, a contract change that will break the provider **should** be communicated to the provider team as a professional courtesy. The pipeline is the safety net, not a substitute for collaboration.

## Complete Implementation Examples

### Basic Pact Setup

```typescript
// src/features/items/repositories/__tests__/setup/pact.setup.ts
import { Pact } from "@pact-foundation/pact";
import path from "path";

export const provider = new Pact({
  consumer: "frontend-app",
  provider: "api-service",
  port: 1234,
  log: path.resolve(process.cwd(), "logs", "pact.log"),
  dir: path.resolve(process.cwd(), "pacts"),
  logLevel: "INFO",
});

export const MOCK_SERVER_URL = "http://localhost:1234";
```

### Entity Repository Contract Test

```typescript
// src/features/items/repositories/__tests__/ItemRepository.pact.test.ts
import { like, eachLike } from "@pact-foundation/pact/dsl/matchers";
import { provider, MOCK_SERVER_URL } from "./setup/pact.setup";
import { ItemRepositoryImpl } from "../ItemRepository";
import { FetchHttpClient } from "@/services/FetchHttpClient";

describe("ItemRepository Contract Tests", () => {
  const httpClient = new FetchHttpClient(MOCK_SERVER_URL);
  const itemRepository = new ItemRepositoryImpl(httpClient);

  beforeAll(async () => {
    await provider.setup();
  });

  afterEach(async () => {
    await provider.verify();
  });

  afterAll(async () => {
    await provider.finalize();
  });

  describe("createItem", () => {
    test("should create a new item successfully", async () => {
      // Arrange
      const newItem = {
        title: "Sample Item",
        description: "Item description",
        category: "electronics",
      };

      await provider.addInteraction({
        state: "the API is available",
        uponReceiving: "a request to create a new item",
        withRequest: {
          method: "POST",
          path: "/api/items",
          headers: {
            "Content-Type": "application/json",
          },
          body: newItem,
        },
        willRespondWith: {
          status: 201,
          headers: {
            "Content-Type": "application/json",
          },
          body: like({
            id: "item-123",
            title: "Sample Item",
            description: "Item description",
            category: "electronics",
            createdAt: "2024-01-01T00:00:00Z",
          }),
        },
      });

      // Act
      const result = await itemRepository.create(newItem);

      // Assert
      expect(result.id).toBeDefined();
      expect(result.title).toBe("Sample Item");
      expect(result.description).toBe("Item description");
      expect(result.category).toBe("electronics");
    });

    test("should handle validation errors", async () => {
      // Arrange
      const invalidItem = {
        title: "", // Invalid empty title
        description: "Item description",
        category: "electronics",
      };

      await provider.addInteraction({
        state: "the API is available",
        uponReceiving: "a request to create an item with invalid data",
        withRequest: {
          method: "POST",
          path: "/api/items",
          headers: {
            "Content-Type": "application/json",
          },
          body: invalidItem,
        },
        willRespondWith: {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
          body: like({
            error: "Validation failed",
            details: eachLike({
              field: "title",
              message: "Title is required",
            }),
          }),
        },
      });

      // Act & Assert
      await expect(itemRepository.create(invalidItem)).rejects.toThrow();
    });
  });

  describe("getItem", () => {
    test("should retrieve an existing item", async () => {
      // Arrange
      const itemId = "item-123";

      await provider.addInteraction({
        state: "an item with ID item-123 exists",
        uponReceiving: "a request to get item by ID",
        withRequest: {
          method: "GET",
          path: `/api/items/${itemId}`,
          headers: {
            Accept: "application/json",
          },
        },
        willRespondWith: {
          status: 200,
          headers: {
            "Content-Type": "application/json",
          },
          body: like({
            id: "item-123",
            title: "Existing Item",
            description: "Item description",
            category: "electronics",
            createdAt: "2024-01-01T00:00:00Z",
          }),
        },
      });

      // Act
      const result = await itemRepository.getById(itemId);

      // Assert
      expect(result.id).toBe(itemId);
      expect(result.title).toBeDefined();
      expect(result.description).toBeDefined();
      expect(result.category).toBeDefined();
    });

    test("should handle item not found", async () => {
      // Arrange
      const itemId = "non-existent-item";

      await provider.addInteraction({
        state: "no item with ID non-existent-item exists",
        uponReceiving: "a request to get a non-existent item",
        withRequest: {
          method: "GET",
          path: `/api/items/${itemId}`,
          headers: {
            Accept: "application/json",
          },
        },
        willRespondWith: {
          status: 404,
          headers: {
            "Content-Type": "application/json",
          },
          body: like({
            error: "Item not found",
            message: `Item with ID ${itemId} does not exist`,
          }),
        },
      });

      // Act & Assert
      await expect(itemRepository.getById(itemId)).rejects.toThrow(
        "Item not found"
      );
    });
  });

  describe("listItems", () => {
    test("should retrieve a list of items", async () => {
      // Arrange
      await provider.addInteraction({
        state: "items exist in the system",
        uponReceiving: "a request to list items",
        withRequest: {
          method: "GET",
          path: "/api/items",
          query: {
            page: "1",
            limit: "10",
          },
          headers: {
            Accept: "application/json",
          },
        },
        willRespondWith: {
          status: 200,
          headers: {
            "Content-Type": "application/json",
          },
          body: like({
            items: eachLike({
              id: "item-123",
              title: "Sample Item",
              description: "Item description",
              category: "electronics",
              createdAt: "2024-01-01T00:00:00Z",
            }),
            pagination: like({
              page: 1,
              limit: 10,
              total: 25,
              totalPages: 3,
            }),
          }),
        },
      });

      // Act
      const result = await itemRepository.list({ page: 1, limit: 10 });

      // Assert
      expect(result.items).toBeDefined();
      expect(Array.isArray(result.items)).toBe(true);
      expect(result.pagination).toBeDefined();
      expect(result.pagination.page).toBe(1);
      expect(result.pagination.limit).toBe(10);
    });

    test("should handle empty results", async () => {
      // Arrange
      await provider.addInteraction({
        state: "no items exist in the system",
        uponReceiving: "a request to list items when none exist",
        withRequest: {
          method: "GET",
          path: "/api/items",
          query: {
            page: "1",
            limit: "10",
          },
          headers: {
            Accept: "application/json",
          },
        },
        willRespondWith: {
          status: 200,
          headers: {
            "Content-Type": "application/json",
          },
          body: like({
            items: [],
            pagination: like({
              page: 1,
              limit: 10,
              total: 0,
              totalPages: 0,
            }),
          }),
        },
      });

      // Act
      const result = await itemRepository.list({ page: 1, limit: 10 });

      // Assert
      expect(result.items).toEqual([]);
      expect(result.pagination.total).toBe(0);
    });
  });
});
```

### Package.json Scripts

```json
{
  "scripts": {
    "test:contract": "jest --testPathPattern=pact",
    "test:contract:watch": "jest --testPathPattern=pact --watch",
    "publish:pacts": "pact-broker publish --consumer-app-version=$GIT_SHA --tag=$BRANCH"
  }
}
```

### Jest Configuration for Pact

```javascript
// jest.pact.config.js
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  testMatch: ["**/*.pact.test.ts"],
  setupFilesAfterEnv: ["<rootDir>/src/__tests__/setup/pact.setup.ts"],
  collectCoverageFrom: [
    "src/**/*.ts",
    "!src/**/*.pact.test.ts",
    "!src/**/__tests__/**",
  ],
};
```
