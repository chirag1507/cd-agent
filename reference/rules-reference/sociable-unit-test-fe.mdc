---
description: Enforce non-negotiable standards for sociable unit tests in frontend projects
globs:
  - "src/**/*"
alwaysApply: false
---

# ðŸ§ª Standard Operating Procedure: Sociable Unit Tests

**Status:** Mandatory  
**Version:** 1.0

**NON-NEGOTIABLE STANDARD:** Adherence to this SOP is mandatory for all Sociable Unit Tests. Deviations are not permitted without explicit architectural review and approval.

## ðŸ“Œ Purpose

This SOP defines the standards for writing Sociable Unit Tests within frontend applications. The primary goal is to ensure that our use cases (application services) and hooks are tested effectively, verifying their behavior and interactions while remaining decoupled from internal implementation details and fast to execute.

---

## Table of Contents

1. [Purpose](#-purpose)
2. [Scope](#scope)
3. [Definitions](#definitions)
4. [Key Principles (Non-Negotiable)](#key-principles-non-negotiable)
   - 4.1. [Behavior-Driven](#behavior-driven)
   - 4.2. [Collaboration Strategy](#collaboration-strategy)
   - 4.3. [Decoupling from Structure, Coupling to Behavior](#decoupling-from-structure-coupling-to-behavior)
   - 4.4. [Speed and Determinism](#speed-and-determinism)
5. [Test Structure (Arrange-Act-Assert)](#test-structure-arrange-act-assert)
6. [Hook Testing Example](#hook-testing-example)
7. [Complete Implementation Examples](#complete-implementation-examples)
8. [Enforcement](#enforcement)

---

## Scope

This SOP applies to all unit tests written for the application layer, specifically targeting Use Case classes and custom hooks.

## Definitions

- **Sociable Unit Test:** A test that verifies the behavior of a "unit" (e.g., a use case class or custom hook) by allowing it to collaborate with its direct, genuine dependencies (like value objects or domain entities) but uses Test Doubles for dependencies that cross process boundaries or represent significant external infrastructure (e.g., HTTP clients, external APIs, browser APIs).
- **Unit:** In the context of this SOP, a "unit" typically refers to a Use Case class, custom hook, or application service and its closely related domain objects (Entities, Value Objects) that it orchestrates.

## Key Principles (Non-Negotiable)

### Behavior-Driven

- **Standard:** Tests MUST verify the observable behavior of the use case or hook from the perspective of a client calling its public interface (e.g., the `execute` method for use cases, or the returned values/functions for hooks).
- **Focus:** Test cases should cover primary success scenarios, key business rule enforcement (including failure scenarios like validation errors or domain errors), and significant interactions with direct collaborators.
- **Example:**
  - `it("should successfully create a new item", ...)`
  - `it("should return error when item already exists", ...)`
  - `it("should validate required fields", ...)`
  - `it("should update loading state during submission", ...)`

### Collaboration Strategy

- **Standard A (Real Collaborators):** Use REAL instances of domain objects (Entities, Value Objects) that the use case or hook directly creates or orchestrates.

  - **Rationale:** The behavior of these core domain objects is integral to the use case's functionality. Mocking them would obscure the true behavior being tested.
  - **Example:** When testing `CreateItemUseCase`, real `Title` and `Description` value objects are created and used.
    ```typescript
    // From a test setup for CreateItemUseCase
    const titleValueObject = Title.create("Sample Item").getValue();
    const descriptionValueObject =
      Description.create("Item description").getValue();
    const itemData = {
      title: titleValueObject,
      description: descriptionValueObject,
    };
    ```

- **Standard B (Test Doubles for Boundaries):** Use Test Doubles (Stubs or Spies, see `SOP-TestDoubles.md`) for dependencies that represent interfaces to:
  - Infrastructure concerns (e.g., `HttpClient`, `NotificationService`).
  - External systems or out-of-process communication.
  - Browser APIs (e.g., `localStorage`, `sessionStorage`).
  - **Rationale:** This ensures tests are fast, deterministic, and focused on the use case logic rather than the implementation details or reliability of external components. The contracts of these interfaces are tested separately (e.g., by Narrow Integration Tests for HTTP client implementations).
  - **Example:**
    ```typescript
    // In beforeEach for CreateItemUseCase tests
    httpClient = {
      post: jest.fn(),
      get: jest.fn(),
    };
    notificationService = {
      showSuccess: jest.fn(),
      showError: jest.fn(),
    };
    useCase = new CreateItemUseCase(httpClient, notificationService);
    ```

### Decoupling from Structure, Coupling to Behavior

- **Standard:** Tests MUST interact with the Use Case or Hook _only_ through its public API. Tests MUST NOT rely on internal methods, properties, or implementation structure of the Use Case or Hook.
- **Rationale:** This ensures that refactoring the internal implementation of a Use Case or Hook (without changing its observable behavior) does not break its tests. This is a core principle of maintainable tests.
- **Verification:** Assertions should be made on:
  1.  The `Result` object returned by the use case's `execute` method.
  2.  The hook's returned values and state changes.
  3.  The interactions with Test Doubles (as per `SOP-TestDoubles.md`), verifying that the correct methods on collaborators were called with expected arguments.

### Speed and Determinism

- **Standard:** Sociable Unit Tests MUST be fast and deterministic.
- **Rationale:** Fast tests are run frequently, providing quick feedback. Determinism ensures reliability.
- **Implementation:** Achieved by using in-memory Test Doubles for I/O-bound or slow dependencies.

## Test Structure (Arrange-Act-Assert)

- **Standard:** All tests MUST follow the Arrange-Act-Assert (AAA) pattern.

  - **Arrange:** Set up the preconditions, including instantiating the use case or setting up hook test environment, preparing its dependencies (real objects or configuring test doubles).
  - **Act:** Execute the public method on the use case or trigger the hook behavior that is being tested.
  - **Assert:** Verify the outcome by checking the returned `Result` object, hook state, and/or asserting interactions with test doubles.

  ```typescript
  it("should successfully create a new item", async () => {
    // Arrange
    const title = "Sample Item";
    const description = "Item description";
    // Configure Test Doubles (Stubs/Spies)
    httpClient.post = jest.fn().mockResolvedValue({
      data: { id: 1, title, description },
      status: 201,
    });
    notificationService.showSuccess = jest.fn().mockResolvedValue(undefined);

    // Act
    const result = await useCase.execute({ title, description });

    // Assert
    expect(result.isSuccess).toBe(true);
    expect(httpClient.post).toHaveBeenCalledWith("/api/items", {
      title,
      description,
    });
    expect(notificationService.showSuccess).toHaveBeenCalledWith(
      "Item created successfully"
    );

    const itemData = result.getValue();
    expect(itemData.title).toBe(title);
    expect(itemData.id).toBe(1);
  });
  ```

## Hook Testing Example

For custom hooks, use React Testing Library's `renderHook`:

```typescript
it("should handle item creation success", async () => {
  // Arrange
  const mockHttpClient = {
    post: jest.fn().mockResolvedValue({
      data: { id: 1, title: "Sample Item", description: "Item description" },
      status: 201,
    }),
  };
  const mockNotificationService = {
    showSuccess: jest.fn(),
  };

  // Act
  const { result } = renderHook(() =>
    useCreateItem(mockHttpClient, mockNotificationService)
  );
  await act(async () => {
    await result.current.createItem("Sample Item", "Item description");
  });

  // Assert
  expect(result.current.isLoading).toBe(false);
  expect(result.current.error).toBeNull();
  expect(mockHttpClient.post).toHaveBeenCalledWith("/api/items", {
    title: "Sample Item",
    description: "Item description",
  });
  expect(mockNotificationService.showSuccess).toHaveBeenCalledWith(
    "Item created successfully"
  );
});
```

## Complete Implementation Examples

### Use Case Sociable Unit Test Template

```typescript
// src/features/items/application/use-cases/create-item/CreateItemUseCase.test.ts
import { CreateItemUseCase } from "./CreateItemUseCase";
import { ItemService } from "../../interfaces/ItemService";
import { NotificationService } from "../../interfaces/NotificationService";
import { Title } from "../../value-objects/Title";
import { Description } from "../../value-objects/Description";

describe("CreateItemUseCase", () => {
  let useCase: CreateItemUseCase;
  let mockItemService: jest.Mocked<ItemService>;
  let mockNotificationService: jest.Mocked<NotificationService>;

  beforeEach(() => {
    mockItemService = {
      create: jest.fn(),
      getById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    };

    mockNotificationService = {
      showSuccess: jest.fn(),
      showError: jest.fn(),
    };

    useCase = new CreateItemUseCase(mockItemService, mockNotificationService);
  });

  describe("execute", () => {
    it("should successfully create a new item", async () => {
      // Arrange
      const title = Title.create("Sample Item").getValue();
      const description = Description.create("Item description").getValue();
      const itemData = { title, description };

      const createdItem = {
        id: "item-123",
        title: "Sample Item",
        description: "Item description",
        createdAt: new Date(),
      };

      mockItemService.create.mockResolvedValue(createdItem);

      // Act
      const result = await useCase.execute(itemData);

      // Assert
      expect(result.isSuccess).toBe(true);
      expect(result.getValue()).toEqual(createdItem);
      expect(mockItemService.create).toHaveBeenCalledWith({
        title: "Sample Item",
        description: "Item description",
      });
      expect(mockNotificationService.showSuccess).toHaveBeenCalledWith(
        "Item created successfully"
      );
    });

    it("should handle validation errors", async () => {
      // Arrange
      const invalidTitle = Title.create(""); // This should fail validation

      // Act & Assert
      expect(invalidTitle.isFailure).toBe(true);
      expect(invalidTitle.getError()).toContain("Title cannot be empty");
    });

    it("should handle service errors", async () => {
      // Arrange
      const title = Title.create("Sample Item").getValue();
      const description = Description.create("Item description").getValue();
      const itemData = { title, description };

      const serviceError = new Error("Database connection failed");
      mockItemService.create.mockRejectedValue(serviceError);

      // Act
      const result = await useCase.execute(itemData);

      // Assert
      expect(result.isFailure).toBe(true);
      expect(result.getError()).toBe("Database connection failed");
      expect(mockNotificationService.showError).toHaveBeenCalledWith(
        "Failed to create item"
      );
    });

    it("should handle duplicate item errors", async () => {
      // Arrange
      const title = Title.create("Existing Item").getValue();
      const description = Description.create("Item description").getValue();
      const itemData = { title, description };

      const duplicateError = new Error("Item with this title already exists");
      mockItemService.create.mockRejectedValue(duplicateError);

      // Act
      const result = await useCase.execute(itemData);

      // Assert
      expect(result.isFailure).toBe(true);
      expect(result.getError()).toContain("already exists");
      expect(mockNotificationService.showError).toHaveBeenCalledWith(
        "Failed to create item"
      );
    });
  });
});
```

### Custom Hook Sociable Unit Test Template

```typescript
// src/features/items/hooks/useCreateItem.test.ts
import { renderHook, act } from "@testing-library/react";
import { useCreateItem } from "./useCreateItem";
import { ItemService } from "../interfaces/ItemService";
import { NotificationService } from "../interfaces/NotificationService";

describe("useCreateItem", () => {
  let mockItemService: jest.Mocked<ItemService>;
  let mockNotificationService: jest.Mocked<NotificationService>;

  beforeEach(() => {
    mockItemService = {
      create: jest.fn(),
      getById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    };

    mockNotificationService = {
      showSuccess: jest.fn(),
      showError: jest.fn(),
    };
  });

  it("should handle successful item creation", async () => {
    // Arrange
    const createdItem = {
      id: "item-123",
      title: "Sample Item",
      description: "Item description",
      createdAt: new Date(),
    };

    mockItemService.create.mockResolvedValue(createdItem);

    // Act
    const { result } = renderHook(() =>
      useCreateItem(mockItemService, mockNotificationService)
    );

    await act(async () => {
      await result.current.createItem("Sample Item", "Item description");
    });

    // Assert
    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBeNull();
    expect(result.current.createdItem).toEqual(createdItem);
    expect(mockItemService.create).toHaveBeenCalledWith({
      title: "Sample Item",
      description: "Item description",
    });
    expect(mockNotificationService.showSuccess).toHaveBeenCalledWith(
      "Item created successfully"
    );
  });

  it("should handle creation errors", async () => {
    // Arrange
    const error = new Error("Network error");
    mockItemService.create.mockRejectedValue(error);

    // Act
    const { result } = renderHook(() =>
      useCreateItem(mockItemService, mockNotificationService)
    );

    await act(async () => {
      await result.current.createItem("Sample Item", "Item description");
    });

    // Assert
    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBe("Network error");
    expect(result.current.createdItem).toBeNull();
    expect(mockNotificationService.showError).toHaveBeenCalledWith(
      "Failed to create item"
    );
  });

  it("should manage loading state correctly", async () => {
    // Arrange
    let resolveCreate: (value: any) => void;
    const createPromise = new Promise((resolve) => {
      resolveCreate = resolve;
    });
    mockItemService.create.mockReturnValue(createPromise);

    // Act
    const { result } = renderHook(() =>
      useCreateItem(mockItemService, mockNotificationService)
    );

    // Start creation (should set loading to true)
    act(() => {
      result.current.createItem("Sample Item", "Item description");
    });

    // Assert loading state
    expect(result.current.isLoading).toBe(true);
    expect(result.current.error).toBeNull();

    // Complete creation
    await act(async () => {
      resolveCreate!({ id: "item-123", title: "Sample Item" });
    });

    // Assert final state
    expect(result.current.isLoading).toBe(false);
  });

  it("should reset error state on new creation attempt", async () => {
    // Arrange
    const { result } = renderHook(() =>
      useCreateItem(mockItemService, mockNotificationService)
    );

    // First failed attempt
    mockItemService.create.mockRejectedValueOnce(new Error("First error"));
    await act(async () => {
      await result.current.createItem("Sample Item", "Item description");
    });
    expect(result.current.error).toBe("First error");

    // Second successful attempt
    mockItemService.create.mockResolvedValueOnce({
      id: "item-123",
      title: "Sample Item",
    });
    await act(async () => {
      await result.current.createItem("Another Item", "Another description");
    });

    // Assert error was cleared
    expect(result.current.error).toBeNull();
  });
});
```

## Enforcement

Violation of these standards will result in build failures during CI and/or rejection during code review. These standards are non-negotiable to maintain the integrity and effectiveness of our testing suite.
