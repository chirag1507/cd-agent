---
description: Enforce non-negotiable standards for narrow integration tests in frontend projects.
---

# ðŸ§ª Standard Operating Procedure: Narrow Integration Tests

**Status:** Mandatory
**Version:** 2.0

**NON-NEGOTIABLE STANDARD:** Adherence to this SOP is mandatory for all Narrow Integration Tests. Deviations are not permitted without explicit architectural review and approval.

## ðŸ“Œ Purpose

This SOP defines the standards for writing Narrow Integration Tests for the application layer of the frontend application. Its primary goal is to ensure that our **custom hooks** are tested effectively, verifying their state management and integration with the application's core logic (Use Cases).

---

## Scope

This standard applies exclusively to tests for **custom hook files** located in `src/features/{feature-name}/hooks/`.

## Definitions

- **Narrow Integration Test:** A test that verifies the correct integration of a vertical slice of the application, from the UI-facing hook down to the mocked I/O boundary. It ensures the "plumbing" between the hook (Interface Adapter) and the Use Case (Application Logic) is correct.

## Key Principles (Non-Negotiable)

- **Focus on Hook State Management:** Tests MUST verify the state changes of the hook (`isLoading`, `errors`, `formData`, etc.). The primary goal is to confirm the hook correctly reflects the status of the underlying operations.
- **Real Use Case Integration:** The test MUST use a **real Use Case instance** to ensure proper integration between hook and application layer. This verifies the "plumbing" is correct.
- **Mock Only I/O Boundaries:** ONLY mock services that represent I/O boundaries (HTTP clients, external APIs, browser storage, notifications, navigation). These are the services the Use Case directly depends on.
- **Use Real Internal Collaborators:** All internal application logic (Use Cases, domain entities, value objects) MUST be real instances, not mocks.
- **Separate State vs Side-Effect Testing:** Create separate tests for hook state transitions vs Use Case service call verification. When testing hook state, use stubs for I/O services to return controlled data. When testing service calls, focus on verifying the correct methods were called with correct parameters.
- **No Framework Mocking Unless Necessary:** Avoid mocking React hooks or Next.js functionality unless they directly interact with external systems.

## Test Structure (Arrange-Act-Assert)

All tests MUST use `@testing-library/react`'s `renderHook` and follow the AAA pattern. Tests for state and side effects SHOULD be separated to ensure clarity and single responsibility.

### Template Example: Generic Hook Integration Testing

```typescript
// Example: src/features/{feature-name}/hooks/use{FeatureName}.integration.test.ts
import { renderHook, act } from '@testing-library/react';
import { use{FeatureName} } from './use{FeatureName}';
import { {FeatureName}UseCase } from '../application/use-cases/{FeatureName}UseCase';
// Import only I/O boundary interfaces that the Use Case depends on

describe('Narrow Integration Test: use{FeatureName} Hook', () => {
  let {featureName}UseCase: {FeatureName}UseCase;
  let mockRepository: jest.Mocked<{FeatureName}Repository>; // I/O boundary
  let mockNotificationService: jest.Mocked<NotificationService>; // I/O boundary
  let mockNavigationService: jest.Mocked<NavigationService>; // I/O boundary
  let mockStorageService: jest.Mocked<StorageService>; // I/O boundary

  beforeEach(() => {
    // 1. Mock ONLY the I/O Boundaries (services Use Case directly depends on)
    mockRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      // ... other I/O operations
    };
    mockNotificationService = { showSuccess: jest.fn(), showError: jest.fn() };
    mockNavigationService = { navigateTo: jest.fn() };
    mockStorageService = { setItem: jest.fn(), getItem: jest.fn() };

    // 2. Create REAL Use Case with mocked I/O dependencies
    {featureName}UseCase = new {FeatureName}UseCase(
      mockRepository,           // I/O boundary
      mockNotificationService,  // I/O boundary
      mockNavigationService,    // I/O boundary
      mockStorageService        // I/O boundary
    );
  });

  // Test 1: Hook State Transitions (use stubs for controlled responses)
  it('should transition through loading and success states correctly', async () => {
    // Arrange: Stub I/O to return controlled data
    const expectedData = { id: '123', name: 'Test' };
    mockRepository.save.mockResolvedValue(expectedData);

    const { result } = renderHook(() => use{FeatureName}({ {featureName}UseCase }));

    // Act: Trigger hook operation
    let promise: Promise<void>;
    act(() => {
      promise = result.current.submit({ name: 'Test' });
    });

    // Assert: Loading State
    expect(result.current.isLoading).toBe(true);
    expect(result.current.errors).toEqual({});

    // Act: Wait for completion
    await act(async () => {
      await promise;
    });

    // Assert: Final Success State
    expect(result.current.isLoading).toBe(false);
    expect(result.current.data).toEqual(expectedData);
  });

  // Test 2: Use Case Service Integration (verify service calls)
  it('should call all required services when operation succeeds', async () => {
    // Arrange
    const inputData = { name: 'Test' };
    const responseData = { id: '123', ...inputData };
    mockRepository.save.mockResolvedValue(responseData);

    const { result } = renderHook(() => use{FeatureName}({ {featureName}UseCase }));

    // Act
    await act(async () => {
      await result.current.submit(inputData);
    });

    // Assert: Verify Use Case called I/O services correctly
    expect(mockRepository.save).toHaveBeenCalledWith(inputData);
    expect(mockNotificationService.showSuccess).toHaveBeenCalledWith(
      expect.stringContaining('success')
    );
    expect(mockNavigationService.navigateTo).toHaveBeenCalledWith('/dashboard');
    expect(mockStorageService.setItem).toHaveBeenCalledWith(
      'app-token',
      responseData.token
    );
  });

  // Test 3: Error State Management
  it('should handle errors and update hook state accordingly', async () => {
    // Arrange
    const errorMessage = 'Operation failed';
    mockRepository.save.mockRejectedValue(new Error(errorMessage));

    const { result } = renderHook(() => use{FeatureName}({ {featureName}UseCase }));

    // Act
    await act(async () => {
      await result.current.submit({ name: 'Test' });
    });

    // Assert: Hook error state
    expect(result.current.isLoading).toBe(false);
    expect(result.current.error).toBe(errorMessage);

    // Assert: Error handling service called
    expect(mockNotificationService.showError).toHaveBeenCalledWith(
      expect.stringContaining('failed')
    );
  });

  // Test 4: Form/Input State Management (if applicable)
  it('should update form state and clear errors on input change', () => {
    // Arrange
    const { result } = renderHook(() => use{FeatureName}({ {featureName}UseCase }));

    // Set an initial error
    act(() => {
      // Trigger validation error
      result.current.onSubmit({ preventDefault: jest.fn() } as any);
    });

    // Act: Change input to clear error
    act(() => {
      result.current.onInputChange('name', 'Valid Name');
    });

    // Assert: Error cleared and data updated
    expect(result.current.formData.name).toBe('Valid Name');
    expect(result.current.errors.name).toBe('');
  });
});
```

### Key Testing Patterns

1. **State-Focused Tests**: Use stubs (controlled return values) to test hook state transitions
2. **Service Integration Tests**: Use mocks with verification to ensure Use Case calls I/O services correctly
3. **Error Handling Tests**: Test both hook error state and Use Case error handling services
4. **Input Management Tests**: Test form state updates and validation error clearing

## Enforcement

Violation of these standards will result in build failures during CI and/or rejection during code review. These standards are non-negotiable to maintain the integrity and effectiveness of our testing suite.
