name: Release to Environment

on:
  workflow_dispatch: # Allows manual triggering
    inputs:
      deploy_to_uat:
        description: "Deploy to UAT environment"
        required: false
        default: true
        type: boolean
      deploy_to_qa:
        description: "Deploy to QA environment"
        required: false
        default: true
        type: boolean
      deploy_lambda:
        description: "Deploy Examination Lambda function"
        required: false
        default: true
        type: boolean
      frontend_commit_sha:
        description: "Frontend commit SHA (e.g., abc1234)"
        required: true
        default: "latest"
      backend_commit_sha:
        description: "Backend commit SHA (e.g., def5678)"
        required: true
        default: "latest"

permissions:
  contents: write
  actions: read
  packages: read

jobs:
  parse_environments:
    name: Parse Environment Selection
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.parse.outputs.environments }}
    steps:
      - name: Parse Environment Selection
        id: parse
        run: |
          ENVS=""
          if [ "${{ github.event.inputs.deploy_to_uat }}" = "true" ]; then
            ENVS="uat"
          fi
          if [ "${{ github.event.inputs.deploy_to_qa }}" = "true" ]; then
            if [ -n "$ENVS" ]; then ENVS="$ENVS,qa"; else ENVS="qa"; fi
          fi
          if [ -z "$ENVS" ]; then echo "‚ùå Error: At least one environment must be selected!"; exit 1; fi
          JSON_ARRAY=$(echo "\"$ENVS\"" | sed 's/,/","/g' | sed 's/^/[/' | sed 's/$/]/')
          echo "environments=$JSON_ARRAY" >> $GITHUB_OUTPUT

  check_can_deploy:
    name: Check if services can be deployed to ${{ matrix.environment }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/pact-cli-environment:latest
    needs: parse_environments
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.parse_environments.outputs.environments) }}
    environment:
      name: ${{ matrix.environment }}
    steps:
      - name: Debug Pact Broker Configuration
        env:
          PACT_BROKER_BASE_URL: ${{ secrets.PACT_BROKER_BASE_URL }}
        run: |
          echo "Pact Broker Base URL (masked): $(echo "$PACT_BROKER_BASE_URL" | cut -c1-8)..."
          if [ -n "$PACT_BROKER_BASE_URL" ]; then
            curl -f -s -o /dev/null "$PACT_BROKER_BASE_URL" && echo "‚úÖ Pact Broker is reachable" || echo "‚ùå Pact Broker connection failed"
          else
            echo "‚ö†Ô∏è PACT_BROKER_BASE_URL is not set"
          fi
      - name: Can I deploy frontend?
        env:
          PACT_BROKER_BASE_URL: ${{ secrets.PACT_BROKER_BASE_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
        run: |
          if [ -z "$PACT_BROKER_BASE_URL" ]; then echo "‚ö†Ô∏è No Pact Broker configured" && exit 0; fi
          pact-broker can-i-deploy --pacticipant code-clinic-frontend --version ${{ github.event.inputs.frontend_commit_sha }} --to-environment ${{ matrix.environment }} --retry-while-unknown 0 --retry-interval 10
      - name: Can I deploy backend?
        env:
          PACT_BROKER_BASE_URL: ${{ secrets.PACT_BROKER_BASE_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
        run: |
          if [ -z "$PACT_BROKER_BASE_URL" ]; then echo "‚ö†Ô∏è No Pact Broker configured" && exit 0; fi
          pact-broker can-i-deploy --pacticipant code-clinic-backend --version ${{ github.event.inputs.backend_commit_sha }} --to-environment ${{ matrix.environment }} --retry-while-unknown 0 --retry-interval 10

  deploy_to_environment:
    name: Deploy to ${{ matrix.environment }} Environment
    runs-on: ubuntu-latest
    needs: [parse_environments, check_can_deploy]
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.parse_environments.outputs.environments) }}
    environment:
      name: ${{ matrix.environment }}
    steps:
      - name: Set Image URIs with Tags
        id: image_uris
        env:
          FRONTEND_INPUT: ${{ github.event.inputs.frontend_image_uri }}
          BACKEND_INPUT: ${{ github.event.inputs.backend_image_uri }}
          REPO_OWNER: ${{ github.repository_owner }}
          FRONTEND_SHA: ${{ github.event.inputs.frontend_commit_sha }}
          BACKEND_SHA: ${{ github.event.inputs.backend_commit_sha }}
          ENVIRONMENT: ${{ matrix.environment }}
        run: |
          frontend_uri_base="${FRONTEND_INPUT:-ghcr.io/${REPO_OWNER}/code-clinic-frontend}"
          backend_uri_base="${BACKEND_INPUT:-ghcr.io/${REPO_OWNER}/code-clinic-backend}"
          if [ "$FRONTEND_SHA" = "latest" ]; then FRONTEND_TAG="latest-${ENVIRONMENT}"; else FRONTEND_TAG="${FRONTEND_SHA}-${ENVIRONMENT}"; fi
          BACKEND_TAG="$BACKEND_SHA"
          echo "FRONTEND_IMG=${frontend_uri_base}:${FRONTEND_TAG}" >> $GITHUB_ENV
          echo "BACKEND_IMG=${backend_uri_base}:${BACKEND_TAG}" >> $GITHUB_ENV
      - name: Set Environment-Specific Configuration
        id: env_config
        env:
          ENVIRONMENT: ${{ matrix.environment }}
        run: |
          if [ "$ENVIRONMENT" = "qa" ]; then
            echo "FRONTEND_PORT=80" >> $GITHUB_ENV; echo "BACKEND_PORT=3001" >> $GITHUB_ENV; echo "ENV_DIR=qa" >> $GITHUB_ENV;
          elif [ "$ENVIRONMENT" = "uat" ]; then
            echo "FRONTEND_PORT=8080" >> $GITHUB_ENV; echo "BACKEND_PORT=3002" >> $GITHUB_ENV; echo "ENV_DIR=uat" >> $GITHUB_ENV;
          else
            echo "Unknown environment: $ENVIRONMENT"; exit 1;
          fi
      - name: Deploy to EC2 via SSH
        uses: appleboy/ssh-action@master
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          UAT_SSH_HOST: ${{ secrets.UAT_SSH_HOST }}
          CLIENT_ID_GITHUB: ${{ secrets.CLIENT_ID_GITHUB }}
          CLIENT_SECRET_GITHUB: ${{ secrets.CLIENT_SECRET_GITHUB }}
          MAILJET_API_KEY: ${{ secrets.MAILJET_API_KEY }}
          MAILJET_SECRET_KEY: ${{ secrets.MAILJET_SECRET_KEY }}
          MAILJET_SENDER_EMAIL: ${{ secrets.MAILJET_SENDER_EMAIL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ACCESS_EXPIRY: ${{ secrets.JWT_ACCESS_EXPIRY }}
          JWT_REFRESH_EXPIRY: ${{ secrets.JWT_REFRESH_EXPIRY }}
          SIGNUP_CALLBACK_URL_GITHUB: ${{ secrets.SIGNUP_CALLBACK_URL_GITHUB }}
          REPO_ACCESS_CALLBACK_URL_GITHUB: ${{ secrets.REPO_ACCESS_CALLBACK_URL_GITHUB }}
          GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY: ${{ secrets.GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY }}
          EXAMINATION_QUEUE_URL: ${{ secrets.EXAMINATION_QUEUE_URL }}
        with:
          host: ${{ secrets.UAT_SSH_HOST }}
          username: ${{ secrets.UAT_SSH_USER }}
          key: ${{ secrets.UAT_SSH_PRIVATE_KEY }}
          port: 22
          envs: FRONTEND_IMG,BACKEND_IMG,UAT_SSH_HOST,DATABASE_URL,GHCR_PAT,CLIENT_ID_GITHUB,CLIENT_SECRET_GITHUB,MAILJET_API_KEY,MAILJET_SECRET_KEY,MAILJET_SENDER_EMAIL,JWT_SECRET,JWT_ACCESS_EXPIRY,JWT_REFRESH_EXPIRY,SIGNUP_CALLBACK_URL_GITHUB,REPO_ACCESS_CALLBACK_URL_GITHUB,GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY,FRONTEND_PORT,BACKEND_PORT,ENV_DIR,EXAMINATION_QUEUE_URL
          script: |
            set -e
            echo "Deploying to $(echo "${ENV_DIR}" | tr '[:lower:]' '[:upper:]') environment..."
            echo "=== Environment Check ==="
            echo "ENV_DIR: ${ENV_DIR}"
            echo "FRONTEND_PORT: ${FRONTEND_PORT}"
            echo "BACKEND_PORT: ${BACKEND_PORT}"
            echo "FRONTEND_IMG: ${FRONTEND_IMG}"
            echo "BACKEND_IMG: ${BACKEND_IMG}"
            echo "========================="

            sudo mkdir -p /opt/code-clinic/${ENV_DIR}
            cd /opt/code-clinic/${ENV_DIR}

            if ! docker compose version &> /dev/null; then
              echo "Installing Docker Compose plugin..."
              sudo mkdir -p /usr/libexec/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-linux-x86_64 -o /usr/libexec/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/libexec/docker/cli-plugins/docker-compose
            fi

            export HOST_ADDRESS=${UAT_SSH_HOST}
            echo "Creating new docker-compose.yml..."
            sudo rm -f docker-compose.yml
            sudo tee docker-compose.yml << EOF
            services:
              frontend:
                image: ${FRONTEND_IMG}
                ports:
                  - "${FRONTEND_PORT}:3000"
                environment:
                  - NODE_ENV=production
                restart: unless-stopped
                depends_on:
                  - backend
                container_name: ${ENV_DIR}-frontend
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3000/"]
                  interval: 10s
                  timeout: 5s
                  retries: 3
                  start_period: 45s
              backend:
                image: ${BACKEND_IMG}
                ports:
                  - "${BACKEND_PORT}:3001"
                environment:
                  - NODE_ENV=${ENV_DIR}
                  - PORT=3001
                  - DATABASE_URL=${DATABASE_URL}
                  - CLIENT_ID_GITHUB=${CLIENT_ID_GITHUB}
                  - CLIENT_SECRET_GITHUB=${CLIENT_SECRET_GITHUB}
                  - MAILJET_API_KEY=${MAILJET_API_KEY}
                  - MAILJET_SECRET_KEY=${MAILJET_SECRET_KEY}
                  - MAILJET_SENDER_EMAIL=${MAILJET_SENDER_EMAIL}
                  - FRONTEND_URL=http://$HOST_ADDRESS$([ "${FRONTEND_PORT}" != "80" ] && echo ":${FRONTEND_PORT}" || echo "")
                  - JWT_SECRET=${JWT_SECRET}
                  - JWT_ACCESS_EXPIRY=${JWT_ACCESS_EXPIRY}
                  - JWT_REFRESH_EXPIRY=${JWT_REFRESH_EXPIRY}
                  - SIGNUP_CALLBACK_URL_GITHUB=${SIGNUP_CALLBACK_URL_GITHUB}
                  - REPO_ACCESS_CALLBACK_URL_GITHUB=${REPO_ACCESS_CALLBACK_URL_GITHUB}
                  - GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY=${GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY}
                  - EXAMINATION_QUEUE_URL=${EXAMINATION_QUEUE_URL}
                  - BACKEND_URL=http://$HOST_ADDRESS:${BACKEND_PORT}
                restart: unless-stopped
                container_name: ${ENV_DIR}-backend
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3001/api/health"]
                  interval: 10s
                  timeout: 5s
                  retries: 3
                  start_period: 45s
                command: >
                  sh -c "npx prisma migrate deploy && node dist/shared/presentation/http/server.js"
            EOF
            sudo chown $USER:$USER docker-compose.yml
            sudo chmod 644 docker-compose.yml

            echo "Verifying docker-compose.yml content:"
            cat docker-compose.yml

            sudo bash -c "cat > /opt/code-clinic/${ENV_DIR}/.env" << EOF
            FRONTEND_IMAGE_URI_WITH_TAG=${FRONTEND_IMG}
            BACKEND_IMAGE_URI_WITH_TAG=${BACKEND_IMG}
            CLIENT_ID_GITHUB=${CLIENT_ID_GITHUB}
            CLIENT_SECRET_GITHUB=${CLIENT_SECRET_GITHUB}
            MAILJET_API_KEY=${MAILJET_API_KEY}
            MAILJET_SECRET_KEY=${MAILJET_SECRET_KEY}
            MAILJET_SENDER_EMAIL=${MAILJET_SENDER_EMAIL}
            JWT_SECRET=${JWT_SECRET}
            JWT_ACCESS_EXPIRY=${JWT_ACCESS_EXPIRY}
            JWT_REFRESH_EXPIRY=${JWT_REFRESH_EXPIRY}
            SIGNUP_CALLBACK_URL_GITHUB=${SIGNUP_CALLBACK_URL_GITHUB}
            REPO_ACCESS_CALLBACK_URL_GITHUB=${REPO_ACCESS_CALLBACK_URL_GITHUB}
            GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY=${GIT_PROVIDER_ACCESS_TOKEN_ENCRYPTION_KEY}
            EXAMINATION_QUEUE_URL=${EXAMINATION_QUEUE_URL}
            BACKEND_URL=http://${HOST_ADDRESS}:${BACKEND_PORT}
            FRONTEND_PORT=${FRONTEND_PORT}
            BACKEND_PORT=${BACKEND_PORT}
            ENV_DIR=${ENV_DIR}
            EOF
            sudo chown $USER:$USER /opt/code-clinic/${ENV_DIR}/.env
            sudo chmod 644 /opt/code-clinic/${ENV_DIR}/.env

            echo "${GHCR_PAT}" | sudo docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin

            echo "Pulling frontend image: ${FRONTEND_IMG}"
            if ! sudo docker pull "${FRONTEND_IMG}"; then echo "ERROR: Failed to pull frontend image: ${FRONTEND_IMG}"; exit 1; fi
            echo "Pulling backend image: ${BACKEND_IMG}"
            if ! sudo docker pull "${BACKEND_IMG}"; then echo "ERROR: Failed to pull backend image: ${BACKEND_IMG}"; exit 1; fi

            echo "Starting services with a rolling update..."
            sudo docker compose up -d

            echo "Waiting for services to be healthy..."
            for i in {1..12}; do
              if sudo docker compose ps --format json | grep -q "\"State\":\"running (healthy)\""; then
                echo "Services are healthy!";
                break
              fi
              echo "Waiting for services to be healthy... ($i/12)";
              sleep 5;
            done

            echo "Testing backend health endpoint on port ${BACKEND_PORT}..."
            HEALTH_CHECK_RESULT=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${BACKEND_PORT}/api/health || echo "failed")
            if [ "$HEALTH_CHECK_RESULT" != "200" ]; then
              echo "Backend health check failed with status: $HEALTH_CHECK_RESULT";
              echo "Backend logs:";
              sudo docker compose logs backend;
              exit 1;
            fi
            echo "Backend health check passed";

            echo "Testing frontend endpoint on port ${FRONTEND_PORT}..."
            FRONTEND_CHECK_RESULT=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${FRONTEND_PORT} || echo "failed")
            if [ "$FRONTEND_CHECK_RESULT" != "200" ]; then
                echo "Frontend health check failed with status: $FRONTEND_CHECK_RESULT"
                echo "Frontend logs:"
                sudo docker compose logs frontend
            else
                echo "Frontend health check passed"
            fi

            echo "üéâ Deployment complete."

  cleanup_old_images:
    name: Cleanup Old Docker Images
    runs-on: ubuntu-latest
    needs: [parse_environments, deploy_to_environment]
    steps:
      - name: Cleanup Old Docker Images via SSH
        uses: appleboy/ssh-action@master
        env:
          DEPLOYED_ENVIRONMENTS: ${{ needs.parse_environments.outputs.environments }}
        with:
          host: ${{ secrets.UAT_SSH_HOST }}
          username: ${{ secrets.UAT_SSH_USER }}
          key: ${{ secrets.UAT_SSH_PRIVATE_KEY }}
          port: 22
          envs: DEPLOYED_ENVIRONMENTS
          script: |
            set -e
            echo "üßπ Cleaning up Docker images for deployed environments..."
            echo "Deployed environments: $DEPLOYED_ENVIRONMENTS"

            cleanup_environment_images() {
              local image_repo=$1
              local env_pattern=$2
              echo "--- Cleaning old images for $image_repo with pattern $env_pattern ---"
              
              # Get images matching the environment pattern, sort by date, keep latest 2
              IMAGES_TO_DELETE=$(sudo docker images "$image_repo" --format '{{.Tag}}\t{{.CreatedAt}}' | grep -E "$env_pattern" | sort -k2,2r | tail -n +3 | awk -v repo="$image_repo" '{print repo ":" $1}')
              
              if [ -n "$IMAGES_TO_DELETE" ]; then
                echo "The following images will be deleted:"
                echo "$IMAGES_TO_DELETE"
                echo "$IMAGES_TO_DELETE" | xargs -r sudo docker rmi
              else
                echo "No old images to delete for pattern $env_pattern (2 or fewer versions found)."
              fi
            }

            # Parse deployed environments and clean only those
            ENVS=$(echo "$DEPLOYED_ENVIRONMENTS" | tr -d '[]"' | tr ',' ' ')
            for env in $ENVS; do
              echo "Cleaning images for environment: $env"
              # For frontend: clean images ending with -${env} or tagged as latest-${env}
              cleanup_environment_images "ghcr.io/${{ github.repository_owner }}/code-clinic-frontend" "(-${env}|latest-${env})"
              # For backend: clean images tagged with commit SHAs (no env suffix)
              # Only clean if this env was deployed (safer approach - clean all backend images when any env is deployed)
            done

            # Backend images don't have env suffixes, so clean them once if any environment was deployed
            echo "--- Cleaning backend images (no env suffix) ---"
            BACKEND_IMAGES_TO_DELETE=$(sudo docker images "ghcr.io/${{ github.repository_owner }}/code-clinic-backend" --format '{{.Tag}}\t{{.CreatedAt}}' | grep -v "latest" | sort -k2,2r | tail -n +3 | awk -v repo="ghcr.io/${{ github.repository_owner }}/code-clinic-backend" '{print repo ":" $1}')
            if [ -n "$BACKEND_IMAGES_TO_DELETE" ]; then
              echo "The following backend images will be deleted:"
              echo "$BACKEND_IMAGES_TO_DELETE"
              echo "$BACKEND_IMAGES_TO_DELETE" | xargs -r sudo docker rmi
            else
              echo "No old backend images to delete (2 or fewer versions found)."
            fi

            echo "‚úÖ Docker image cleanup complete."

  deploy_lambda:
    name: Deploy Lambda to ${{ matrix.environment }}
    runs-on: ubuntu-latest
    needs: [parse_environments, check_can_deploy]
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.parse_environments.outputs.environments) }}
    environment:
      name: ${{ matrix.environment }}
    steps:
      - name: Download Lambda Artifact from Release
        if: github.event.inputs.deploy_lambda == 'true' && matrix.environment == 'qa'
        uses: robinraju/release-downloader@v1
        with:
          repository: ${{ github.repository_owner }}/code-clinic-backend
          tag: build-${{ github.event.inputs.backend_commit_sha }}
          fileName: examination-lambda.zip
          token: ${{ secrets.PAT_FOR_BACKEND_REPO }}

      - name: Configure AWS CLI
        if: github.event.inputs.deploy_lambda == 'true' && matrix.environment == 'qa'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set Lambda Function Name
        if: github.event.inputs.deploy_lambda == 'true' && matrix.environment == 'qa'
        run: echo "FUNCTION_NAME=code-clinic-uat-examination-processor" >> $GITHUB_ENV

      - name: Deploy Lambda Function
        if: github.event.inputs.deploy_lambda == 'true' && matrix.environment == 'qa'
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DIAGNOSTICS_QUEUE_URL: ${{ secrets.DIAGNOSTICS_QUEUE_URL }}
        run: |
          ENV_VARS_JSON=$(jq -n \
            --arg NODE_ENV "${{ matrix.environment }}" \
            --arg DATABASE_URL "$DATABASE_URL" \
            --arg OPENAI_API_KEY "$OPENAI_API_KEY" \
            --arg DIAGNOSTICS_QUEUE_URL "$DIAGNOSTICS_QUEUE_URL" \
            '{Variables: {NODE_ENV: $NODE_ENV, DATABASE_URL: $DATABASE_URL, OPENAI_API_KEY: $OPENAI_API_KEY, DIAGNOSTICS_QUEUE_URL: $DIAGNOSTICS_QUEUE_URL}}')
          echo "$ENV_VARS_JSON" > env.json
          if aws lambda get-function --function-name $FUNCTION_NAME 2>/dev/null; then
            echo "Updating existing Lambda function: $FUNCTION_NAME"
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --zip-file fileb://examination-lambda.zip
            aws lambda update-function-configuration \
              --function-name $FUNCTION_NAME \
              --environment file://env.json
            echo "Waiting for function update to complete..."
            aws lambda wait function-updated --function-name $FUNCTION_NAME
          else
            echo "‚ùå Error: Lambda function $FUNCTION_NAME does not exist."
            exit 1
          fi

  record_deployment_and_state:
    name: Record Deployment and State for ${{ matrix.environment }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/pact-cli-environment:latest
    needs: [parse_environments, deploy_to_environment, deploy_lambda]
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.parse_environments.outputs.environments) }}
        include:
          - environment: qa
            frontend_port: 80
            backend_port: 3001
          - environment: uat
            frontend_port: 8080
            backend_port: 3002
    environment:
      name: ${{ matrix.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Record deployment to Pact Broker
        env:
          PACT_BROKER_BASE_URL: ${{ secrets.PACT_BROKER_BASE_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
        run: |
          if [ -z "$PACT_BROKER_BASE_URL" ]; then echo "‚ö†Ô∏è No Pact Broker configured"; exit 0; fi
          pact-broker record-deployment --pacticipant code-clinic-frontend --version ${{ github.event.inputs.frontend_commit_sha }} --environment ${{ matrix.environment }}
          pact-broker record-deployment --pacticipant code-clinic-backend --version ${{ github.event.inputs.backend_commit_sha }} --environment ${{ matrix.environment }}
      - name: Record Deployed Versions for Acceptance Tests
        run: |
          git config --global --add safe.directory /__w/code-clinic/code-clinic
          mkdir -p state
          DEPLOY_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          ENVIRONMENT="${{ matrix.environment }}"
          HOST="${{ secrets.UAT_SSH_HOST }}"
          if [ "$ENVIRONMENT" = "qa" ]; then FRONTEND_URL="http://${HOST}"; else FRONTEND_URL="http://${HOST}:${{ matrix.frontend_port }}"; fi
          BACKEND_URL="http://${HOST}:${{ matrix.backend_port }}"
          cat <<EOF > state/${ENVIRONMENT}-deployed-versions.json
          {"frontend":{"version":"${{ github.event.inputs.frontend_commit_sha }}","url":"$FRONTEND_URL","port":${{ matrix.frontend_port }}},"backend":{"version":"${{ github.event.inputs.backend_commit_sha }}","url":"$BACKEND_URL","port":${{ matrix.backend_port }}},"deployed_at":"$DEPLOY_TIMESTAMP","environment":"$ENVIRONMENT","host":"$HOST"}
          EOF
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          for attempt in $(seq 1 5); do
            echo "Attempt $attempt to push state..."
            git fetch origin
            git reset --hard origin/main
            cat <<EOF > state/${ENVIRONMENT}-deployed-versions.json
          {"frontend":{"version":"${{ github.event.inputs.frontend_commit_sha }}","url":"$FRONTEND_URL","port":${{ matrix.frontend_port }}},"backend":{"version":"${{ github.event.inputs.backend_commit_sha }}","url":"$BACKEND_URL","port":${{ matrix.backend_port }}},"deployed_at":"$DEPLOY_TIMESTAMP","environment":"$ENVIRONMENT","host":"$HOST"}
          EOF
            git add state/${ENVIRONMENT}-deployed-versions.json
            if git diff --staged --quiet; then echo "No changes to commit."; exit 0; fi
            git commit -m "CI: Record $(echo "$ENVIRONMENT" | tr '[:lower:]' '[:upper:]') deployment - Frontend:${{ github.event.inputs.frontend_commit_sha }} Backend:${{ github.event.inputs.backend_commit_sha }}"
            if git push origin main; then echo "‚úÖ Successfully pushed state"; exit 0; fi
            echo "Push failed, retrying in $((attempt * 2)) seconds..."
            sleep $((attempt * 2))
          done
          echo "‚ùå Failed to push state after 5 attempts"; exit 1

  run_smoke_tests:
    name: Run Smoke Tests on ${{ matrix.environment }}
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/playwright-test-environment:latest
    needs: [parse_environments, deploy_to_environment, deploy_lambda]
    if: success()
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.parse_environments.outputs.environments) }}
    steps:
      - name: Checkout System Tests Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/code-clinic-system-test
          path: code-clinic-system-test
          token: ${{ secrets.PAT_FOR_SYSTEM_TESTS_REPO }}
      - name: Install System Test Dependencies
        working-directory: ./code-clinic-system-test
        run: npm ci
      - name: Run Smoke Tests
        working-directory: ./code-clinic-system-test
        env:
          NODE_ENV: ${{ matrix.environment }}
          BASE_URL: http://${{ secrets.UAT_SSH_HOST }}${{ matrix.environment == 'uat' && ':8080' || '' }}
          API_URL: http://${{ secrets.UAT_SSH_HOST }}:${{ matrix.environment == 'qa' && '3001' || '3002' }}/api
          CI: true
        run: |
          echo "Running smoke tests against ${{ matrix.environment }}..."
          npm run test:smoke
